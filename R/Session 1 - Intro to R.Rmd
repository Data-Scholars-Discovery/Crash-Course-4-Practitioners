---
title: "Data Science Crash Course 4 Practitioners"
subtitle: "Session 1 - Introduction to R and RStudio"
author: "Aaron Scherf"
date: "June 28, 2019"
output:
  html_document: default
  pdf_document: default
---


```{r setup, include=FALSE}
require("knitr")
knitr::opts_chunk$set(echo = TRUE)
opts_knit$set(root.dir = "C:/Users/theaa/Desktop/Crash-Course-4-Practitioners")

```


## Today's Commands
* `summary()`
* `print()`
* `sqrt()`
* `ls()`
* `remove()`
* `getwd()`
* `setwd()`
* `list.files()`
* `paste()`
* `list.dirs()`
* `read.csv()`
* `head()`
* `c()`
* `data.frame()`
* `summary()` again
* `mean()`


## 0. Welcome to R!

R is an incredibly diverse, open-source statistical programming language that is rapidly becoming a mainstay of data scientists and researchers around the world. There is a large and growing online community offering tutorials (like this one), user-created packages, and entire user interfaces (like RStudio). 

R operates like most programming languages (and is quite similar to Python or Stata, if you've ever used those), in that it has its own grammar and vocabulary based on commands and functions. Code is usually written in scripts or Markdown documents (like this one) and executed either from the script or directly in the command console (usually found below). RStudio offers a traditional navigation tab at the top, with "File" and "Edit" options that should be familiar to anyone that has used a word processor.

### R Markdown

This file you are reading is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents that is shared by many programs. We will mostly be using it for simple text and "chunks" of code. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button (at the top of the session window) a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

Anything written inside of the code chunk (between the three back-ticks, which are usually found below the tilde ~ on a keyboard) can be run as R code by pressing the little green play button at the top right of the chunk (or pressing ctrl-enter for Windows, cmd-enter for Macs). The play button will run the entire chunk, whereas clicking and pressing ctrl-enter will just run one line (unless you select multiple lines).

Everything else is text that will appear in the output document. You can format the text using Markdown syntax, a common language shared by many programs (like GitHub and Jupyter Notebooks). Some common Markdown formatting options are titles and subtitles (made by starting a line with a #, ##, or up to six #'s) and hyperlinks, such as [this link to a markdown cheatsheet](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet).

Go ahead and try running the {r cars} chunk above. A summary table of the example dataset `cars` should appear, showing statistics for two variables, `speed` and `dist`. The `cars` dataset is pre-loaded with RStudio so it's good for introductory examples.



## 1. Objects and the Global Environment

R is an object-oriented programming language. This just means that much of our work is done by creating temporary objects out of data like numbers, character strings, files, etc. This lets us reference the same data multiple times in a script quickly without having to specify the source. Later, when we import data from a comma-separated value (CSV) file, we only have to import it once and save it as an object, then we can call on the data many times by using the object name.

You can make objects (or run any code) using the console (similar to the command line, usually at the bottom of the RStudio interface). Most programmers prefer to write code in a script (like this R Markdown document) so that they can run it again or share it with others (the console by itself doesn't "save" your work in a file, though you can see a history of your commands).

Let's get used to running commands inside our script, since this is generally best practice for [reproducibility](https://datacarpentry.org/rr-intro/02-toolkit/).


```{r example_commands}
2+2
2+2 == 4
print("hello_world")
sqrt(4)
sqrt(2+2)
```

As you can see, commands in R can be arithmetic (mathematical), logical (testing if things are `TRUE` or `FALSE`), functions like `print()` or `sqrt()`, or a combination of these. Much of learning R is knowing different functions and how they fit together. Few people have memorized every possible function, so most of us rely extensively on the "Help" search on the bottom right window. 

If you don't know how to do something, start typing that thing in the help search bar, chances are you'll find the function you need. If not, Google has fantastic resources from the global R-community, including StackOverflow answers. About 80% of your programming time, at least at the start, will be spent looking up functions or example code and adapting it to your needs. This isn't stealing or cheating (unless you take code and pretend it's yours) so please borrow liberally from other sources (like these guides)!

When you execute a command, R will print out the result, as you saw above. You can also use the `print()` function to achieve the same output. This output can also be saved to an object and re-used later. Let's use the `sqrt(2+2)` example to show how we can save a command to an object and re-use it. Try running each line separately first using ctrl+enter before running the entire chunk.


```{r object_example}
four = 2+2
four
four / 2
```

Notice how the output wasn't printed until you called the object `four` by running it by itself. Python won't automatically print the contents of an object when you make it. Also note that you can then use the object in subsequent code, treating it just like you would the contents `2+2` or, as it evaluates the math, `4`.

Note how the `=` was used in the first line. In this case, `four` is just a string of letters until it is assigned to the output of the function `2+2`. By writing out `four` and assigning it with the `=` we are telling R to save the formula `2+2` in a shorthand (actually it's longer but you get the idea) that we named `four`. 

Note the difference between the single `=` that is used to assign objects and the `==` that runs a logical test of equivalency. `==` checks to see if the surrounding values are equal, and if so prints the logical value `TRUE`.


```{r logic_test}
four == 4
```

By itself, unless you previously assign it as an object, `four` means nothing arithmetically to R. We can see this if you try it with another character string.


```{r letters_not_numbers, error=TRUE}
six + 4
```

`six` by itself means nothing to R, unless you assign it as an object.


```{r math_with_words}
six = 12 / 2
six + four
```

Now R can add the two objects `four` and `six` because you assigned them values. If you assign other values to the same name, it will overwrite the object you made before, so be careful with re-using names.


```{r overwrite}
four = 3
six + four
```

R won't judge you for making silly objects, like `four` being 3, but anyone you share your code with will, so be sure to use sensible names that would be comprehensible to others. This isn't required, necessarily, but it's good coding practice and will help make things easier for you and other programmers. We're all in this together, after all.



### Introducing: The Global Environment

Whenever you create an object by assigning values to a name, you should see the object in your **Global Environment** window at the top right. Your environment should currently contain all the objects we already made, with a small preview or description of their values next to their names.

Your global environment keeps track of all the objects you've created within the R session. These objects are stored in your computer's temporary memory, so if you quit the R session (even if you save the script file) the objects won't stay. You should get a prompt asking if you want to save the **workspace image** to a **.`RData** file. You can save the objects in the environment to this type of file, to make opening and editing a script faster, but generally you won't have to since the script will be able to reproduce the environment if you run it in its entirety.



## 2. Clearing the Global Environment

One common way to start all of your R scripts and Markdown documents is with a command to clear the global environment. This clears away any variables (objects) saved to your workspace from previous commands, which can help avoid errors when working with lots of objects. 

The first building block of the command to clear the environment is calling all the objects in your environment, using the **List Objects** command `ls()`:


```{r list_objects}
ls()
```

This should print out a list of character strings for all the object names in your environment. We prefer to use the names rather than the values, since some objects can contain thousands (or millions) of values. Notice that `ls()` calls a list, not just a single value, so you can use the square bracket to index a specific item.


```{r bracket_index}
ls()[2]
```


Now that we can call all of our objects in the global environment, you can then clear the environment with the following command:


```{r clear}
remove(list = ls())
```

This command may look a bit obtuse at first, but it is pretty intuitive if you break it down. `ls()` calls the objects in your environment, the `list =` portion is an input argument that specifies the objects called by `ls()`, and the `remove()` function removes them. 

Note how the "outer" function is `remove()`. `list =` is an argument being input to that function, while `ls()` is another function that uses the default arguments (and is therefore blank within the parentheses).

If you run the `ls()` command with an empty environment it will report an empty `character(0)` string.


```{r clear_again}
ls()
```

The objects we assigned earlier are gone, so if we tried to call `two` R won't know what to do:


```{r object_error, error=TRUE}
two
```

See the error message? The object `two` is not found in the environment. Since R is object-oriented, however, you can scroll back up to the chunk that created the object `two`, run that, and then come call it with the "object_error" chunk above and it will print the value. Commands can be run out-of-order, though it's good practice to put them in the "right" order so that you can re-run the script later on.

What if we only wanted to remove certain objects but not others? Let's make two objects and see.


```{r two_objects}
two = 2
hello_world = "hello_world"
```

Now we have two objects: our `two` (which is numeric) and a new `hello_world` (which is a character string). We can call either using their name.


```{r call_objects_again}
two
hello_world
```

If we just want to remove the `two` object we can use the `remove()` function. We don't need to use the `list =` argument since we are specifying particular objects.


```{r remove_two}
remove(two)
```


## 3. Working Directory and File Paths

You can make and define data files in R, but more often than not you will be importing data that was generated elsewhere to manipulate with R. Importing files requires telling R where on your computer (or in the cloud) it is, which is usually defined by some kind of **filepath**. Folders on your computer are logical representations of these filepaths, often consisting of a nested list of paths or **directories**, culminating in the folder that contains the file you want. You can constantly just reference the entire filepath to call a file, but since programmers are lazy we often shorten the path into an object and tell R to default towards a certain folder. This is called the **working directory**.

If you just call a file with an import command without any filepath, R will begin by searching the working directory. R typically defaults to a folder associated with your R installation when you open a new session. You can always check where your current working directory is with the `getwd()` function.


```{r get_wd}
getwd()
```

You can see that the filepath is expressed as a character string, with various formats for Windows, Macs, etc. Checking the current directory is helpful, but more often you want to start off a new script by setting the working directory to the folder you are working from using `setwd()`.


### Change the Working Directory


```{r set_wd}
setwd("C:/Users/theaa/Desktop/Crash-Course-4-Practitioners")
```

It's often good practice to organize your projects in a familiar way. Everyone does their folder structures differently but it's common to have a `Data` folder and various output folders, like `Plots` or `Logs` (meaning log-files). It's typical to set your working directory to the overall project folder (sometimes the `Master` folder, though personally I think it sounds weird). Then you can specify the sub-folder (like `Data`) when you call the file to import data, or create character strings for all of your various folders.

You can always open the folder you are working in using the regular old file explorer on your computer, but as programmers we don't like to leave the **Matrix** that is typing into a screen of code. To view the names of files inside of your directory, you can use the `list.files()` function.


```{r list_files}
list.files()
```

If you leave the part inside the parentheses blank (not passing any arguments into the function, therefore calling it using the default settings), `list.files()` will list all of the folders and files in your working directory as text strings. This is useful to navigate and change your working directory by drilling down into sub-folders. We can make an object out of our `Data` folder filepath, taking a shortcut by saving our working directory as a character object.


```{r data_path}
Path = getwd()
Path
Data_Path = paste(Path,"/Data", sep = "")
Data_Path
```

Let's break down what each of the four lines above is doing:

`Path = getwd()` is storing your current working directory as a character string object, `Path`.

`Path` is then called, leading to the first filepath you see in the printout.

`Data_Path` is a new object we are assigning to the character string combination (using the `paste()` function) of the `Path` object and a character string `"/Data"`. The `paste()` function takes both character strings as inputs as well as the argument `sep = ""`, which tells it to not put any separator between the two strings of text.

`Data_Path` is then called to print the second filepath.

Now you have both a root directory `Path` and a specific `Data_Path` directory. You can then examine the files inside the `Data_Path` with `list.files()`.


### List Files in the Directory


```{r list_data_files}
list.files(Data_Path)
```

Your `Data` folder should contain at least the `housing.csv` file. You may also have other folders in your directory, which it could be helpful to inspect in case you need to identify the folder-path to a particular sub-directory. `list.dirs()` is similar to `list.files()`, but it will list the folders and all of their sub-folders in your directory. If you leave the argument inside the parentheses blank it will default to your working directory.


```{r list_dirs}
list.dirs()
```


## 4. Importing and Viewing CSV Files

Now that we can set and explore our directories, it's a simple process to import data from a CSV file. The function is easy to remember: `read.csv()`

Let's import the `housing.csv` file that is in our data directory (if it isn't make sure to download the data from its [source on Kaggle](https://www.kaggle.com/camnugent/california-housing-prices/downloads/california-housing-prices.zip/1) or from the [Crash Course GitHub repo](https://github.com/Data-Scholars-Discovery/Crash-Course-4-Practitioners)).

If you haven't used GitHub before, just click the green **Clone or Download** button at the top right, then select **Download Zip**. GitHub is the standard open-source data sharing and file management system, built on its own programming language called Git. You don't need to know Git to use GitHub but eventually it will become necessary, so best to get in the practice of using GitHub now. For a basic intro to GitHub check out the [GitHub Guides on their website](https://guides.github.com/activities/hello-world/).

Either way, make sure you have the `housing.csv` file in a folder called `Data` inside your main working directory before running the following command.



```{r import_csv, results=FALSE}
read.csv("Data/housing.csv")
```


Great, looks like a typical dataframe laid out spreadsheet style with rows of observations and columns of variables! But where is it in our global environment? We still need to save it as an object.


```{r save_csv_object}
Housing = read.csv("Data/housing.csv")
```

Once you successfully import the csv file, it's a simple matter to call it again to explore the data or start calling summary statistics. One quick way to examine the data, other than printing it all out like above, is the `head()` function. This prints out just the first 6 rows so you can see the different variables and their formats.


```{r head}
head(Housing)
```


### Intermission: Finding New Data

There is a lot of data out there but if you're interested in finding your own data we recommend searching through the following sources:

* [Kaggle Datasets](https://www.kaggle.com/datasets)
* [re3data Resources by Subject](https://www.re3data.org/browse/by-subject/)
* [World Health Organization Global Health Observatory](https://www.who.int/gho/database/en/)
* [World Bank Open Data](https://data.worldbank.org/)
* [Google Public Data](https://www.google.com/publicdata/directory)
* [Harvard Dataverse](https://dataverse.harvard.edu/)


## 5. Creating a Dataframe and Indexing

Most of your analysis will be on pre-existing data. It's rare to actually build a full data set using R, unless you automate it with a function. However, it's helpful to learn about making dataframes to better understand the structure and how the indexing system works. Dataframes are objects which can contain different types of data (numeric, string, logical, etc.) organized into columns. You can think of an Excel spreadsheet made up of rows and columns, where rows typically represent a single observation, while columns represent variables. Columns are also often called **series**.

Series can be saved as objects in R by assigning them to a name with the combine function `c()`.


```{r combine}
city_names = c('San Francisco', 'New York City', 'Austin')
population = c(884363, 8623000, 950715)
```

Now we have two new objects, which are both groups of three data points. `city_names` contains three text strings, while `population` has numeric values. These can then be combined into a dataframe using the `data.frame()` function, which orders the two series into two columns, with the position of each data point reflecting its row. You can think of transposing the two lines above (turning them sidewise) to make a dataframe with 3 rows and 2 columns


```{r data_frame}
City_Data = data.frame(city_names,population)
head(City_Data)
```

See how the dataframe is structured? The numbers to the left of the rows indicate the row position of each value. You can call specific rows, columns, or values from within the dataframe using the index position.


```{r index}
City_Data[1]
City_Data[2]
City_Data[1,]
City_Data[,1]
City_Data[1,1]
```

Let's break down all the index positions above:
`City_Data[1]` calls the first series (or column), which is identical to the `city_names`.
`City_Data[2]` calls the second series, which is identical to `population`.
`City_Data[1,]` calls the first row, with San Francisco and its population.
`City_Data[,1]` calls the first column, with all the city names. Notice that the first command, `City_Data[1]' calls the series as an object, while this calls it as a text string.
`City_Data[1,1]` calls the data value which is in the first row and first column, which is just the text string for "San Francisco"

Don't worry if you get confused which is which. You can always test it out or look it up. Just knowing how the numerical index system works is the important thing. Also, fun fact, R starts its index at 1 while Python and some other langauges start at 0. I'm sure there is a reason for this but mostly it's just a funny argument between R and Python programmers.

Another common way to index within a dataframe is to call the name of a column using the `$` sign. When you construct a dataframe from series, the name of the series by default becomes the name of the column (also referred to as a variable, in typical survey data form).


```{r call_variable}
City_Data$city_names
City_Data$city_names[1]
```

Notice how you can also use indexing with the variable call `$` to specify the first value in the series `city_names`. Now that you can select columns you can start generating summary statistics!



## 6. Basic Descriptive Statistics


The easiest way to generate summary stats is, unsurprisingly, the use of the `summary()` function, which we saw at the beginning of the lesson.


```{r summary_housing}
summary(Housing)
```

As you can see, by default `summary()` calls up the minimum, quartiles, median, mean and max for each numeric variable. Notice the difference in `Housing$ocean_proximity`. Since it isn't a numeric variable (but rather categoric, based on character strings) it shows a count of observations in each category. You'll also notice it tells you how many missing values, or `NA's` are in each column: 207 in `Housing$total_bedrooms`.

You can also call these particular summary statistics in isolation with their own functions. This could be helpful in case you want to include them inside another function. But, unlike `summary()` you have to specify a particular variable. The simplest way to do this is by calling its name after the `$` like so.


```{r mean_housing}
mean(Housing$total_rooms)
```



## Conclusion and Review

This process of clearing the environment, setting the working directory, importing a dataset, and summarizing its variables is often the first part of every data analysis project you will do. Congratulations, you're officially doing data science!

To review, here are the functions we learned today:

* `summary()`
* `print()`
* `sqrt()`
* `ls()`
* `remove()`
* `getwd()`
* `setwd()`
* `list.files()`
* `paste()`
* `list.dirs()`
* `read.csv()`
* `head()`
* `c()`
* `data.frame()`
* `summary()` again
* `mean()`


If you don't recognize any of these or what they do please feel free to go back up and review. These are all "bread and butter" commands that you will be using quite a lot, so make sure to know what they are. If you want to explore them in even more detail you can also look them up in the **Help** files search to the right. The help-file for each function will give you a description, list of possible arguments and their default values, and some example code. It's always good to check the help-file whenever you are using a new function!


Again, welcome to the R community! Our next lesson will focus on basic data management within dataframes.

